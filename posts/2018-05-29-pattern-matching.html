<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Adαm Schønemαnn - Pattern matching ADTs</title>
        <link rel="stylesheet" href="../css/adsc-blog.css" />
        <link rel="stylesheet" href="../css/pygments-default.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Adαm Schønemαnn</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../blog.html">Blog</a>
                <a href="https://github.com/adamschoenemann" target="_blank">GitHub</a>
                <a href="https://www.linkedin.com/in/adamschoenemann/" target="_blank">LinkedIn</a>
                <a href="https://seafile.adamschoenemann.dk/f/26a72b627abc485ab106/?dl=1" target="_blank">Resumé</a>
                <a href="../rss.xml">RSS</a>
            </nav>
        </header>

        <main role="main">
            <h1>Pattern matching ADTs</h1>
            <article>
    <section class="header">
        Posted on May 29, 2018
        
    </section>
    <section>
        <p>This post is about implementing coverage checking of pattern matches using Haskell. It does not involve any super-advanced type-level trickery, so as long you're somewhat comfortable with monad transformers you should be fine.</p>
<h2 id="introduction">Introduction</h2>
<p>Pattern matching coverage on generalized algebraic data types is a complicated problem, and has seen many attempts at a solution in recent years. In contrast, pattern matching on ordinary ADTs is often simply mentioned as a trivial matter and delegated to a footnoote. When I recently had to implement a coverage checking algorithm in a Haskell-like language <em>without</em> GADTs, I found that there was a dearth of information (which was not paywalled) on how to go about such a problem. Specifically, I needed to disallow not only non-exhaustive matches but also redundant matches. Eventually, I devised a solution that is a small modification of a well-known algorithm. I don't expect that there is anything academically novel about my modification, but I do wish that I hadn't spent so much time searching in vain for a ready-made solution. This blog post is my attempt at rectifying this state of affairs for those that come after me!</p>
<p>When dealing with pattern matching clauses, we can typically encounter two kinds of problems:</p>
<ul>
<li><p>The clauses are non-exhaustive; for example</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  [] <span class="ot">-&gt;</span> <span class="fu">...</span></a></code></pre></div>
In this example, we have clearly not dealt with the case where <code>xs</code> is a cons constructed list. If we accept such a match we can introduce divergence into our language very easily.</li>
<li><p>There are one or more redundant clauses; for example</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  [] <span class="ot">-&gt;</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  x <span class="fu">:</span> xs' <span class="ot">-&gt;</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  xs' <span class="ot">-&gt;</span> <span class="fu">...</span></a></code></pre></div>
<p>In this example, the last branch is essentially dead code, as it will never be reached.</p></li>
</ul>
<p>The only information I could find on the internet on coverage checking was Conor McBride's <a href="https://stackoverflow.com/questions/7883023/algorithm-for-type-checking-ml-like-pattern-matching">great StackOverflow answer</a> which explains the core idea <a href="https://dl.acm.org/citation.cfm?id=5303">behind Lennart Augustsson's technique for compiling pattern matches</a>. I also found a kindred spirit in Tim Humphries who had encountered the same lack of information and devised <a href="https://teh.id.au/posts/2017/03/10/simple-exhaustivity/index.html">an algorithm using tries</a>.</p>
<p>The problem was that I could not get McBride's explanation to account for <em>redundant pattern matches</em>. McBride explains how to use the algorithm to flag <em>overlapping patterns</em>, but this is too strong a requirement. For example,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  [] <span class="ot">-&gt;</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  xs' <span class="ot">-&gt;</span> <span class="fu">...</span></a></code></pre></div>
<p>would be flagged as an issue, since <code>xs'</code> strictly overlaps with <code>[]</code>. But this is rarely what we want since we often use catch-all patterns for convenience.</p>
<p>While I only took a cursory look at Tim Humphries' implementation, it did not appear to make any attempt at checking anything beyond exhaustivity, so I could not steal his code shamelessly either.</p>
<p>After pouring over McBride's explanation for many hours, I eventually discovered how to modify it to suit my needs by introducing just a tiny bit of extra state.</p>
<h2 id="the-language">The language</h2>
<p>With that out of the way, let us start modeling our problem in Haskell.</p>
<p>Since this is a literate Haskell file, we'll kick things off with some obligatory language extensions and imports.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Control.Monad.Except</span> (<span class="dt">ExceptT</span>, runExceptT, <span class="dt">MonadError</span>, throwError)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Control.Monad.State</span> (<span class="dt">StateT</span>, runStateT, <span class="dt">MonadState</span>, get, modify)</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span> (<span class="dt">Reader</span>, runReader, <span class="dt">MonadReader</span>, asks, local)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (foldlM)</a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Control.Monad</span> (replicateM)</a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.Maybe</span> (catMaybes)</a></code></pre></div>
<p>None of these extensions or imports should worry you right now.</p>
<p>We need to define the language of types and patterns we'll be working on. Lets keep it simple.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Type</span> </a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">TConstr</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Pattern</span> ident</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="fu">=</span> <span class="dt">PBind</span> ident</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">PMatch</span> <span class="dt">String</span> [<span class="dt">Pattern</span> ident]</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Types are just an open set of nullary type constructors. So for example <code>Unit</code> or <code>Boolean</code> or <code>IntList</code>. Our language does not have polymorphism, but the algorithm will work fine with a bit of extra machinery for polymorphic types as well (<a href="https://github.com/adamschoenemann/clofrp/blob/master/library/CloFRP/Check/Coverage.hs">demonstration</a>).</p>
<p>Patterns are only slightly more complicated. A pattern can <em>bind</em> a value or it can <em>match</em> (destructure) a value. As an example, the clauses in</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="dt">Cons</span> x xs' <span class="ot">-&gt;</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  xs' <span class="ot">-&gt;</span> <span class="fu">...</span></a></code></pre></div>
<p>would be encoded as</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">[ <span class="dt">PMatch</span> <span class="st">&quot;Cons&quot;</span> [<span class="dt">PBind</span> <span class="st">&quot;x&quot;</span>, <span class="dt">PBind</span> <span class="st">&quot;xs'&quot;</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">, <span class="dt">PBind</span> <span class="st">&quot;xs&quot;</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">]</a></code></pre></div>
<p>We'll refrain from use infix pattern-operators like <code>(:)</code> and instead use their &quot;ordinary&quot; prefix-form names (e.g. <code>Cons</code> for <code>(:)</code>) just to simplify our implementation and presentation.</p>
<p>You'll notice that <code>Pattern</code> is parameterized over <code>ident</code>. We use this to distinguish patterns with user-given names and fresh machine-generated names.</p>
<h2 id="an-initial-algorithm">An initial algorithm</h2>
<p>Disclaimer: just to be absolutely clear, this algorithm is mostly due to <a href="https://dl.acm.org/citation.cfm?id=5303">Augustsson</a> and just a small extension of the outline provided by <a href="https://stackoverflow.com/questions/7883023/algorithm-for-type-checking-ml-like-pattern-matching">Conor McBride's StackOverflow answer</a>. I don't pretend to have invented anything novel.</p>
<p>Here is a sketch of how the algorithm works.</p>

<p>The expression <span class="math inline">\(q\, \mathsf{coveredBy}\, ρ\)</span> checks if an &quot;ideal pattern&quot; <span class="math inline">\(q\)</span> is covered by a list of actual patterns <span class="math inline">\(ρ\)</span>. The ideal pattern starts off being a simple name-binding pattern, and is further refined when needed through the algorithm.</p>
<ul>
<li>If <span class="math inline">\(ρ\)</span> is the empty list, then we cannot cover <span class="math inline">\(q\)</span> and the match is not exhaustive.</li>
<li>If there is a substitution of variables <span class="math inline">\(υ\)</span> in <span class="math inline">\(q\)</span> such that <span class="math inline">\(υ\, q\)</span> (<span class="math inline">\(υ\)</span> applied to <span class="math inline">\(q\)</span>) equals <span class="math inline">\(\mathsf{head}(ρ)\)</span> then:
<ul>
<li>If the substitution <span class="math inline">\(υ\)</span> is an <em>injective renaming of variables</em>, then we know that <span class="math inline">\(q\)</span> is fully covered by <span class="math inline">\(\mathsf{head}(ρ)\)</span>. Such a substitution only maps variables to variables.</li>
<li>Otherwise, then there is a mapping in <span class="math inline">\(υ\)</span> that maps a variable <span class="math inline">\(x_1\)</span> to a constructor. For each constructor <span class="math inline">\(c_i\)</span> of <span class="math inline">\(x_1\)</span>'s type, apply the substitution <span class="math inline">\(\left[x_1 ↦ c_i\right]\)</span> to <span class="math inline">\(q\)</span> giving <span class="math inline">\(q'\)</span>, and solve <span class="math inline">\(q'\, \mathsf{coveredBy}\, ρ\)</span>.</li>
</ul></li>
<li>If no such substitution exists, then <span class="math inline">\(q\)</span> cannot be covered by <span class="math inline">\(\mathsf{head}(ρ)\)</span> and so we recurse with <span class="math inline">\(q\, \mathsf{coveredBy}\, \mathsf{tail}(ρ)\)</span>.</li>
</ul>
<h1 id="an-example">An example</h1>
<p>The algorithm above will not detect redundant patterns, but before we extend it to do so, let us see an example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">case</span> xs <span class="kw">of</span> </a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="dt">Cons</span> x' xs' <span class="ot">-&gt;</span> <span class="fu">...</span></a></code></pre></div>
<p>This gives the problem <code>xs coveredBy [Nil, Cons x' xs']</code></p>
<p>We start comparing <code>xs</code> to <code>Nil</code>. There is a valid substitution <span class="math inline">\(υ\)</span>, namely <code>[xs ↦ Nil]</code>. Since <code>Nil</code> is not a variable, <span class="math inline">\(υ\)</span> is not injective, so we have to &quot;split&quot; on <code>xs</code> with each list constructor, giving us problems:</p>
<pre><code>Nil coveredBy [Nil, Cons x' xs']
Cons a´ b´ coveredBy [Nil, Cons x' xs']</code></pre>
<p>Here, <code>a´</code> and <code>b´</code> are fresh names, so we postfix them with a tick for clarity.</p>
<p>The first sub-problem has a solution of the empty substitution (which is injective) so we can discharge that. The second sub-problem will first try to find a substitution to unify <code>Cons a´ b´</code> and <code>Nil</code>, but no such substitution exists, so we'll discard <code>Nil</code> and move on to the next pattern.</p>
<pre><code>Cons a´ b´ coveredBy [Cons x' xs']</code></pre>
<p>There is an obvious injective substitution, namely <code>[a´ ↦ x', b´ ↦ xs']</code>, and the algorithm terminates with success.</p>
<h2 id="redundant-patterns">Redundant patterns</h2>
<p>In McBride's answer, he shows how to detect any <em>overlapping</em> patterns. Whenever we discharge a case through an injective substitution, we can check that there are no other covering patterns in our list. To use his example:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  ys <span class="ot">-&gt;</span> <span class="fu">...</span></a></code></pre></div>
<pre><code>xs coveredBy [Nil, ys]
  Nil coveredBy [Nil, ys] &lt;-- overlap with ys
  Cons a´ b´ coveredBy [Nil, ys]</code></pre>
<p>But this is not what we really want, since we want to permit catch-all patterns. My solution was to simply keep track of how many times a clause was used to discharge an ideal pattern, and then check that every clause was used at least once after the algorithm terminated. Using this scheme, the example above would be permitted, whereas</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">case</span> xs <span class="kw">of</span> </a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="dt">Cons</span> x' xs' <span class="ot">-&gt;</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  ys <span class="ot">-&gt;</span> <span class="fu">...</span> </a></code></pre></div>
<p>would be flagged, since the last clause is redundant.</p>
<p>Now that we've extended the original algorithm a bit and we have a better understanding of the problem, we can try to write a more detailed algorithm in pseudo-Haskell before proceeding to the implementation.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">checkCoverage ::</span> <span class="dt">IdealPattern</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="kw">of</span> <span class="dt">Clauses</span> <span class="ot">-&gt;</span> <span class="dt">Success</span> or <span class="dt">Failure</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">checkCoverage q ρ <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">if</span> q <span class="ot">`coveredBy`</span> ρ</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    <span class="kw">then</span> <span class="kw">if</span> any ρᵢ was not used return <span class="dt">Failure</span> (ρᵢ is redundant)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    <span class="kw">else</span> <span class="dt">Success</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="ot">coveredBy ::</span> <span class="dt">IdealPattern</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="kw">of</span> <span class="dt">Clauses</span> <span class="ot">-&gt;</span> <span class="dt">Success</span> or <span class="dt">Failure</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">q <span class="ot">`coveredBy`</span> ρ <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  <span class="kw">if</span> ρ is the empty list</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">    <span class="kw">then</span> <span class="dt">Failure</span> (q is not covered<span class="fu">!</span>)</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  <span class="kw">else</span> </a>
<a class="sourceLine" id="cb14-12" data-line-number="12">    <span class="kw">let</span> υ <span class="fu">=</span> a substitution such that υ q <span class="fu">=</span> (head ρ)   or  nothing</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    <span class="kw">if</span> υ is nothing</a>
<a class="sourceLine" id="cb14-14" data-line-number="14">      <span class="kw">then</span> q <span class="ot">`coveredBy`</span> (tail ρ)</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">    <span class="kw">else</span> </a>
<a class="sourceLine" id="cb14-16" data-line-number="16">      <span class="kw">if</span> υ is injective </a>
<a class="sourceLine" id="cb14-17" data-line-number="17">        <span class="kw">then</span> increment the usages <span class="kw">of</span> (head ρ) with <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-18" data-line-number="18">        <span class="kw">else</span> </a>
<a class="sourceLine" id="cb14-19" data-line-number="19">          <span class="kw">let</span> x <span class="fu">=</span> the variable <span class="kw">in</span> q that must map to some constructor</a>
<a class="sourceLine" id="cb14-20" data-line-number="20">          <span class="kw">let</span> τ <span class="fu">=</span> typeOf x</a>
<a class="sourceLine" id="cb14-21" data-line-number="21">          for each c <span class="kw">in</span> (constructorsOf τ)</a>
<a class="sourceLine" id="cb14-22" data-line-number="22">            <span class="kw">let</span> q' <span class="fu">=</span> q with x substituted for c</a>
<a class="sourceLine" id="cb14-23" data-line-number="23">            q' <span class="ot">`coveredBy`</span> ρ</a></code></pre></div>
<h2 id="implementation">Implementation</h2>
<p>We'll start by formalizing some of the concepts used in the pseudo-code algorithm.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">type</span> <span class="dt">ClausePattern</span> <span class="fu">=</span> <span class="dt">Pattern</span> <span class="dt">Name</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="kw">type</span> <span class="dt">FreshName</span> <span class="fu">=</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">type</span> <span class="dt">IdealPattern</span> <span class="fu">=</span> <span class="dt">Pattern</span> <span class="dt">FreshName</span></a></code></pre></div>
<p>These type synonyms will just make our code a bit more readable. We'll also need to fetch the constructors for a type at some point, so let's define those:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Constructor</span> <span class="fu">=</span> <span class="dt">Constructor</span> <span class="dt">Name</span> [<span class="dt">Type</span>]</a></code></pre></div>
<p>For example, the constructors of <code>IntList</code> are <code>Constructor &quot;Nil&quot; []</code> and <code>Constructor &quot;Cons&quot; [TConstr &quot;Int&quot;, TConstr &quot;IntList&quot;]</code>.</p>
<p>The pseudo-code mentions substitutions, so lets define what a substitution actually is.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Subst</span> ident <span class="fu">=</span> <span class="dt">Subst</span> {<span class="ot"> unSubst ::</span> [(<span class="dt">FreshName</span>, <span class="dt">Pattern</span> ident)] }</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Monoid</span>)</a></code></pre></div>
<p>We'll just use a newtype wrapper around an associative list. A more efficient implementation would of course be a <code>Map</code>, but for now let's keep things simple. Note that the domain of the substitution will alwas be <code>FreshName</code> since we never touch the patterns that the user has defined.</p>
<p>Using structural recursion over <code>Pattern</code> we can apply a substitution to a pattern, giving us a new pattern.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">apply ::</span> <span class="dt">Subst</span> <span class="dt">FreshName</span> <span class="ot">-&gt;</span> <span class="dt">Pattern</span> <span class="dt">FreshName</span> <span class="ot">-&gt;</span> <span class="dt">Pattern</span> <span class="dt">FreshName</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">apply (<span class="dt">Subst</span> assocs) <span class="fu">=</span> go <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  go (<span class="dt">PBind</span> i) </a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">Just</span> pat' <span class="ot">&lt;-</span> lookup i assocs <span class="fu">=</span> pat'</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    <span class="fu">|</span> otherwise                    <span class="fu">=</span> <span class="dt">PBind</span> i</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  go (<span class="dt">PMatch</span> nm subpats) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    <span class="dt">PMatch</span> nm (map go subpats)</a></code></pre></div>
<p>We'll also need to know if a substitution is injective. We'll use a new data type to represent this.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> <span class="dt">IsInjectiveResult</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Injective</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">NotInjective</span> <span class="dt">FreshName</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>A substitution is either injective, or not-injective due to a binding. This data type is isomorphic to <code>Maybe</code> but <code>Maybe</code>'s established semantics do not fit very well to this problem, we we'll use our own data type.</p>
<p>We can easily establish whether a substitution is injective by recursing over the list it wraps.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">isInjective ::</span> <span class="dt">Subst</span> ident <span class="ot">-&gt;</span> <span class="dt">IsInjectiveResult</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">isInjective (<span class="dt">Subst</span> xs) <span class="fu">=</span> go xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  go [] <span class="fu">=</span> <span class="dt">Injective</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  go ((b, p) <span class="fu">:</span> xs') <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="kw">case</span> p <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="dt">PBind</span> _    <span class="ot">-&gt;</span> go xs'</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    <span class="dt">PMatch</span> _ _ <span class="ot">-&gt;</span> <span class="dt">NotInjective</span> b</a></code></pre></div>
<p>If we look at the pseudo-Haskell algorithm, we can identify some helper functions that we will most definitely need. We can also see that the computation must be able to fail in a few different ways. Seems like we'll need a monad! We can create a type class that allows us to abstract over the exact representation of our computation, which will force us to stay at the domain-level when we're writing the implementation.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Coverage</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="co">-- get the type of a name-binding</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">  getType ::</span> <span class="dt">FreshName</span> <span class="ot">-&gt;</span> m <span class="dt">Type</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="co">-- get the constructors of a type</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="ot">  getConstructors ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> m [<span class="dt">Constructor</span>]</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  <span class="co">-- extend the computation with bindings of names to types</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="ot">  withTypes ::</span> [(<span class="dt">FreshName</span>, <span class="dt">Type</span>)] <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  <span class="co">-- get a fresh name</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="ot">  freshName ::</span> m <span class="dt">FreshName</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">  <span class="co">-- fail a coverage check</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="ot">  coverageError ::</span> <span class="dt">CoverageError</span> <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>A coverage-check can fail for the reasons specified in the pseudo-Haskell, but we could also encounter some more &quot;low-level&quot; errors, like malformed patterns, empty types or a failing lookup of types or constructors.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">CoverageError</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">RedundantClauses</span> [<span class="dt">ClausePattern</span>]</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">CannotCover</span> <span class="dt">IdealPattern</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">MalformedPattern</span> <span class="dt">ClausePattern</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">EmptyType</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">NoTypeFound</span> <span class="dt">FreshName</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">NoConstructorsFound</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>Since we're associating a number (usages) with each input clause, we'll create a datatype to maintain this association.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Clause</span> <span class="fu">=</span> <span class="dt">Clause</span> {<span class="ot"> usages ::</span> <span class="dt">Integer</span>,<span class="ot"> pattern ::</span> <span class="dt">ClausePattern</span> }</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">useClause ::</span> <span class="dt">Clause</span> <span class="ot">-&gt;</span> <span class="dt">Clause</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">useClause br <span class="fu">=</span> br { usages <span class="fu">=</span> usages br <span class="fu">+</span> <span class="dv">1</span> }</a></code></pre></div>
<p>Looking at the specification, we could make do with a boolean field since we only keep track of the used/not-used state of clauses. I'll stick with the <code>Integer</code> field though, as it could potentially be useful information, for debugging purposes if nothing else.</p>
<p>With the main plumbing out of the way, we can jump right into the implementation of the <code>coveredBy</code> function, which checks that the patterns are exhaustive and updates the clauses with their number of usages.</p>
<h1 id="coveredby">coveredBy</h1>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co">-- the explicit forall is so we can refer back to `m` in the signature of the</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="co">-- where-binding</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="ot">coveredBy ::</span> forall m<span class="fu">.</span> (<span class="dt">Coverage</span> m) <span class="ot">=&gt;</span> <span class="dt">IdealPattern</span> <span class="ot">-&gt;</span> [<span class="dt">Clause</span>] <span class="ot">-&gt;</span> m [<span class="dt">Clause</span>]</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">coveredBy ideal [] <span class="fu">=</span> coverageError (<span class="dt">CannotCover</span> ideal)</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">coveredBy ideal (clause <span class="fu">:</span> clauses) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  ideal <span class="ot">`hasSubst`</span> pattern clause <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb24-8" data-line-number="8">      (clause <span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> coveredBy ideal clauses</a>
<a class="sourceLine" id="cb24-9" data-line-number="9"></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">    <span class="dt">Just</span> subst <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">      <span class="kw">case</span> isInjective subst <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-12" data-line-number="12">        <span class="dt">Injective</span> <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb24-13" data-line-number="13">          pure (useClause clause <span class="fu">:</span> clauses)</a>
<a class="sourceLine" id="cb24-14" data-line-number="14"></a>
<a class="sourceLine" id="cb24-15" data-line-number="15">        <span class="dt">NotInjective</span> binding <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-16" data-line-number="16">          typ <span class="ot">&lt;-</span> getType binding</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">          constructors <span class="ot">&lt;-</span> getConstructors typ</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">          foldlM (coveredByRefined binding) (clause <span class="fu">:</span> clauses) constructors</a>
<a class="sourceLine" id="cb24-19" data-line-number="19"></a>
<a class="sourceLine" id="cb24-20" data-line-number="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-21" data-line-number="21"><span class="ot">    coveredByRefined ::</span> <span class="dt">FreshName</span> <span class="ot">-&gt;</span> [<span class="dt">Clause</span>] <span class="ot">-&gt;</span> <span class="dt">Constructor</span> <span class="ot">-&gt;</span> m [<span class="dt">Clause</span>]</a>
<a class="sourceLine" id="cb24-22" data-line-number="22">    coveredByRefined fname clauses' constructor <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-23" data-line-number="23">      (refineTo, refinedTypes) <span class="ot">&lt;-</span> constructorToPattern constructor</a>
<a class="sourceLine" id="cb24-24" data-line-number="24">      <span class="kw">let</span> refined <span class="fu">=</span> apply (<span class="dt">Subst</span> [(fname, refineTo)]) ideal</a>
<a class="sourceLine" id="cb24-25" data-line-number="25">      withTypes refinedTypes (refined <span class="ot">`coveredBy`</span> clauses')</a></code></pre></div>
<p>We update the usages of the clauses by returning them from the function. Even if we do not use a clause, we will still need to return it, so it won't &quot;disappear&quot; from the set of clauses for the next sub-problem. The main divergence from the pseudo-Haskell is the <code>coveredByRefined</code> helper function, which is iterated over the constructors of the type of the binding that we're splitting on. It uses the <code>constructorToPattern</code> function to convert a constructor of a type to a pattern.</p>
<h1 id="constructortopattern">constructorToPattern</h1>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">constructorToPattern ::</span> <span class="dt">Coverage</span> m <span class="ot">=&gt;</span> <span class="dt">Constructor</span> <span class="ot">-&gt;</span> m (<span class="dt">IdealPattern</span>, [(<span class="dt">FreshName</span>, <span class="dt">Type</span>)])</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">constructorToPattern (<span class="dt">Constructor</span> nm args) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="kw">let</span> arglen <span class="fu">=</span> length args</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  freshNames <span class="ot">&lt;-</span> replicateM arglen freshName</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  <span class="kw">let</span> typeAssocs <span class="fu">=</span> zip freshNames args</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  pure (<span class="dt">PMatch</span> nm (map <span class="dt">PBind</span> freshNames), typeAssocs)</a></code></pre></div>
<p>Here we both generate fresh names to stand in for the arguments of the constructor, but we also return a list associating the names to their appropriate types.</p>
<h1 id="hassubst">hasSubst</h1>
<p>We also need to know if an ideal pattern can transformed into a covering pattern through a substitution, which we can define as</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">hasSubst ::</span> <span class="dt">Coverage</span> m <span class="ot">=&gt;</span> <span class="dt">IdealPattern</span> <span class="ot">-&gt;</span> <span class="dt">ClausePattern</span> <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (<span class="dt">Subst</span> <span class="dt">Name</span>))</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">hasSubst (<span class="dt">PBind</span> x) pat <span class="fu">=</span> pure <span class="fu">.</span> pure <span class="fu">$</span> <span class="dt">Subst</span> [(x, pat)]</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">hasSubst (<span class="dt">PMatch</span> nm1 pats1) (<span class="dt">PMatch</span> nm2 pats2)</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  <span class="fu">|</span> nm1 <span class="fu">/=</span> nm2 <span class="fu">=</span> </a>
<a class="sourceLine" id="cb26-5" data-line-number="5">      pure <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb26-6" data-line-number="6">  <span class="fu">|</span> length pats1 <span class="fu">/=</span> length pats2 <span class="fu">=</span> </a>
<a class="sourceLine" id="cb26-7" data-line-number="7">      coverageError (<span class="dt">MalformedPattern</span> (<span class="dt">PMatch</span> nm2 pats2))</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  <span class="fu">|</span> null pats1 <span class="fu">=</span> pure (<span class="dt">Just</span> mempty)</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">  <span class="fu">|</span> otherwise <span class="fu">=</span> </a>
<a class="sourceLine" id="cb26-10" data-line-number="10">      mconcat <span class="fu">&lt;$&gt;</span> (sequence (zipWith hasSubst pats1 pats2))</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">hasSubst (<span class="dt">PMatch</span> _ _) (<span class="dt">PBind</span> _) <span class="fu">=</span> pure (<span class="dt">Just</span> mempty)</a></code></pre></div>
<ul>
<li><span class="math inline">\(x\, \mathsf{hasSubst}\, p\)</span> is always the substitution <span class="math inline">\([x ↦ p]\)</span>.<br />
</li>
<li><span class="math inline">\((c\, p_1 \dots p_n)\; \mathsf{hasSubst}\; (c\, p'_1 \dots p'_n)\)</span> is just the concatenation of the substitutions of the sub-patterns.<br />
</li>
<li>The last case is somewhat interesting as it says that <span class="math inline">\((c\, p_1 \dots p_n)\; \mathsf{hasSubst}\; x\)</span> is just the empty substitution. This is contrary to Augustsson's method, where this is not true. Instead, the clauses are refined along with the ideal pattern, so such a case does not occur. I could not find a good reason to do this though, so I chose to bake in this notion of generality instead.</li>
</ul>
<h1 id="checkcoverage">checkCoverage</h1>
<p>We can now put the icing on the cake and define the function that actually aplies the coverage checking algorithm!</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">checkCoverage ::</span> <span class="dt">Coverage</span> m <span class="ot">=&gt;</span> <span class="dt">IdealPattern</span> <span class="ot">-&gt;</span> [<span class="dt">ClausePattern</span>] <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">checkCoverage ideal userpats <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  checkedClausees <span class="ot">&lt;-</span> ideal <span class="ot">`coveredBy`</span> (map asClause userpats) </a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">case</span> unusedPatterns checkedClausees <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5">    [] <span class="ot">-&gt;</span> pure ()</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    unreached <span class="ot">-&gt;</span> coverageError <span class="fu">$</span> <span class="dt">RedundantClauses</span> unreached</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">  <span class="kw">where</span> </a>
<a class="sourceLine" id="cb27-8" data-line-number="8">    asClause pat <span class="fu">=</span> <span class="dt">Clause</span> { usages <span class="fu">=</span> <span class="dv">0</span>, pattern <span class="fu">=</span> pat }</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10">    unusedPatterns clauses <span class="fu">=</span> </a>
<a class="sourceLine" id="cb27-11" data-line-number="11">      <span class="kw">let</span> onlyUnused <span class="fu">=</span> \cl <span class="ot">-&gt;</span> <span class="kw">if</span> usages cl <span class="fu">&lt;</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dt">Just</span> (pattern cl) <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">      <span class="kw">in</span>  catMaybes (map onlyUnused clauses)</a></code></pre></div>
<p>It is very like the pseudo-Haskell specification, but with a bit more book-keeping to set up and tear down the state we need.</p>
<h2 id="testing-our-code">Testing our code</h2>
<p>Now, we can start working out how to actually run and test our algorithm. We have to start by picking a concrete datatype to implement our <code>Coverage</code> type class.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">CoverageM</span> r <span class="fu">=</span> <span class="dt">CoverageM</span> </a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  {<span class="ot"> unCoverageM ::</span> </a>
<a class="sourceLine" id="cb28-3" data-line-number="3">      <span class="dt">ExceptT</span> </a>
<a class="sourceLine" id="cb28-4" data-line-number="4">        <span class="dt">CoverageError</span> </a>
<a class="sourceLine" id="cb28-5" data-line-number="5">        (<span class="dt">StateT</span> <span class="dt">CoverageState</span> (<span class="dt">Reader</span> <span class="dt">CoverageRead</span>)) r </a>
<a class="sourceLine" id="cb28-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">  <span class="kw">deriving</span> ( <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">           , <span class="dt">Applicative</span></a>
<a class="sourceLine" id="cb28-9" data-line-number="9">           , <span class="dt">Monad</span></a>
<a class="sourceLine" id="cb28-10" data-line-number="10">           , <span class="dt">MonadError</span> <span class="dt">CoverageError</span></a>
<a class="sourceLine" id="cb28-11" data-line-number="11">           , <span class="dt">MonadState</span> <span class="dt">CoverageState</span></a>
<a class="sourceLine" id="cb28-12" data-line-number="12">           , <span class="dt">MonadReader</span> <span class="dt">CoverageRead</span></a>
<a class="sourceLine" id="cb28-13" data-line-number="13">           )</a>
<a class="sourceLine" id="cb28-14" data-line-number="14"></a>
<a class="sourceLine" id="cb28-15" data-line-number="15"><span class="kw">data</span> <span class="dt">CoverageRead</span> <span class="fu">=</span> <span class="dt">CoverageRead</span> </a>
<a class="sourceLine" id="cb28-16" data-line-number="16">  {<span class="ot"> crTypes ::</span> [(<span class="dt">FreshName</span>, <span class="dt">Type</span>)]</a>
<a class="sourceLine" id="cb28-17" data-line-number="17">  ,<span class="ot"> crConstructors ::</span> [(<span class="dt">Type</span>, [<span class="dt">Constructor</span>])]</a>
<a class="sourceLine" id="cb28-18" data-line-number="18">  }</a>
<a class="sourceLine" id="cb28-19" data-line-number="19"></a>
<a class="sourceLine" id="cb28-20" data-line-number="20"><span class="kw">type</span> <span class="dt">CoverageState</span> <span class="fu">=</span> <span class="dt">Integer</span></a></code></pre></div>
<p>We use the <code>GeneralizedNewtypeDeriving</code> language extension along with monad transformers to derive a bunch of nifty functionality for us! If you're not familiar with monad transformers, this might look a bit arcane, but it really is just boilerplate. To keep things simple, we again use associative lists where <code>Map</code> might be more appropriate.</p>
<p>We can now make our <code>CoverageM</code> monad an instance of our <code>Coverage</code> type class, and then define a way to run a computation in our monad.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Coverage</span> <span class="dt">CoverageM</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  getType uid <span class="fu">=</span> </a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    asks crTypes</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    <span class="fu">&gt;&gt;=</span> maybe (coverageError <span class="fu">$</span> <span class="dt">NoTypeFound</span> uid) pure <span class="fu">.</span> lookup uid</a>
<a class="sourceLine" id="cb29-5" data-line-number="5"></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">  getConstructors typ <span class="fu">=</span> </a>
<a class="sourceLine" id="cb29-7" data-line-number="7">    asks crConstructors</a>
<a class="sourceLine" id="cb29-8" data-line-number="8">    <span class="fu">&gt;&gt;=</span> maybe (coverageError <span class="fu">$</span> <span class="dt">NoConstructorsFound</span> typ) noEmptyTypes <span class="fu">.</span> lookup typ</a>
<a class="sourceLine" id="cb29-9" data-line-number="9">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-10" data-line-number="10">      noEmptyTypes [] <span class="fu">=</span> coverageError (<span class="dt">EmptyType</span> typ)</a>
<a class="sourceLine" id="cb29-11" data-line-number="11">      noEmptyTypes cs <span class="fu">=</span> pure cs</a>
<a class="sourceLine" id="cb29-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb29-13" data-line-number="13">  withTypes types <span class="fu">=</span> local (\r <span class="ot">-&gt;</span> r { crTypes <span class="fu">=</span> types <span class="fu">++</span> crTypes r })</a>
<a class="sourceLine" id="cb29-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb29-15" data-line-number="15">  freshName <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> (\i <span class="ot">-&gt;</span> modify (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">&gt;&gt;</span> pure i)</a>
<a class="sourceLine" id="cb29-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb29-17" data-line-number="17">  coverageError <span class="fu">=</span> throwError</a>
<a class="sourceLine" id="cb29-18" data-line-number="18"></a>
<a class="sourceLine" id="cb29-19" data-line-number="19">runCoverageM</a>
<a class="sourceLine" id="cb29-20" data-line-number="20"><span class="ot">  ::</span> <span class="dt">CoverageState</span></a>
<a class="sourceLine" id="cb29-21" data-line-number="21">  <span class="ot">-&gt;</span> <span class="dt">CoverageRead</span></a>
<a class="sourceLine" id="cb29-22" data-line-number="22">  <span class="ot">-&gt;</span> <span class="dt">CoverageM</span> a</a>
<a class="sourceLine" id="cb29-23" data-line-number="23">  <span class="ot">-&gt;</span> (<span class="dt">Either</span> <span class="dt">CoverageError</span> a, <span class="dt">CoverageState</span>)</a>
<a class="sourceLine" id="cb29-24" data-line-number="24">runCoverageM st rd (<span class="dt">CoverageM</span> x) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb29-25" data-line-number="25">  runReader (runStateT (runExceptT x) st) rd</a></code></pre></div>
<p>Finally, we can test our algorithm on some example inputs. Normally, I would use a testing framework like <a href="https://hackage.haskell.org/package/tasty">Tasty</a>, but for this blog post let us just do some quick and dirty testing.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">test ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">test <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="kw">let</span> tunit <span class="fu">=</span> <span class="dt">TConstr</span> <span class="st">&quot;Unit&quot;</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  specify <span class="st">&quot;simple tests&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5">    <span class="kw">let</span> rd <span class="fu">=</span> <span class="dt">CoverageRead</span> [<span class="dv">0</span> <span class="fu">|-&gt;</span> tunit] [tunit <span class="fu">|-&gt;</span> [<span class="dt">Constructor</span> <span class="st">&quot;MkUnit&quot;</span> []]]</a>
<a class="sourceLine" id="cb30-6" data-line-number="6"></a>
<a class="sourceLine" id="cb30-7" data-line-number="7">    runCoverageM <span class="dv">0</span> rd (checkCoverage (<span class="dt">PBind</span> <span class="dv">0</span>) [<span class="dt">PMatch</span> <span class="st">&quot;MkUnit&quot;</span> []])</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">      <span class="ot">`shouldBe`</span> (<span class="dt">Right</span> (), <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb30-9" data-line-number="9"></a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    runCoverageM <span class="dv">0</span> rd (checkCoverage (<span class="dt">PBind</span> <span class="dv">0</span>) [<span class="dt">PMatch</span> <span class="st">&quot;Just&quot;</span> []])</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">      <span class="ot">`shouldBe`</span> (<span class="dt">Left</span> (<span class="dt">CannotCover</span> (<span class="dt">PMatch</span> <span class="st">&quot;MkUnit&quot;</span> [])), <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb30-12" data-line-number="12"></a>
<a class="sourceLine" id="cb30-13" data-line-number="13">    runCoverageM <span class="dv">0</span> rd (checkCoverage (<span class="dt">PBind</span> <span class="dv">0</span>) [<span class="dt">PMatch</span> <span class="st">&quot;MkUnit&quot;</span> [], <span class="dt">PBind</span> <span class="st">&quot;x&quot;</span>])</a>
<a class="sourceLine" id="cb30-14" data-line-number="14">      <span class="ot">`shouldBe`</span> (<span class="dt">Left</span> (<span class="dt">RedundantClauses</span> [<span class="dt">PBind</span> <span class="st">&quot;x&quot;</span>]), <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb30-15" data-line-number="15"></a>
<a class="sourceLine" id="cb30-16" data-line-number="16">  specify <span class="st">&quot;slightly more advanced&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-17" data-line-number="17">    <span class="kw">let</span> rd <span class="fu">=</span> <span class="dt">CoverageRead</span> </a>
<a class="sourceLine" id="cb30-18" data-line-number="18">          [ <span class="dv">0</span> <span class="fu">|-&gt;</span> <span class="dt">TConstr</span> <span class="st">&quot;UnitList&quot;</span> ] </a>
<a class="sourceLine" id="cb30-19" data-line-number="19">          [ <span class="dt">TConstr</span> <span class="st">&quot;UnitList&quot;</span> <span class="fu">|-&gt;</span> </a>
<a class="sourceLine" id="cb30-20" data-line-number="20">            [ <span class="dt">Constructor</span> <span class="st">&quot;Nil&quot;</span> []</a>
<a class="sourceLine" id="cb30-21" data-line-number="21">            , <span class="dt">Constructor</span> <span class="st">&quot;Cons&quot;</span> [tunit, <span class="dt">TConstr</span> <span class="st">&quot;UnitList&quot;</span>]</a>
<a class="sourceLine" id="cb30-22" data-line-number="22">            ]</a>
<a class="sourceLine" id="cb30-23" data-line-number="23">          , tunit <span class="fu">|-&gt;</span> [<span class="dt">Constructor</span> <span class="st">&quot;MkUnit&quot;</span> []]</a>
<a class="sourceLine" id="cb30-24" data-line-number="24">          ]</a>
<a class="sourceLine" id="cb30-25" data-line-number="25"></a>
<a class="sourceLine" id="cb30-26" data-line-number="26">    specify <span class="st">&quot;shallow match works&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-27" data-line-number="27">      <span class="kw">let</span> branches <span class="fu">=</span> [<span class="dt">PMatch</span> <span class="st">&quot;Cons&quot;</span> [<span class="dt">PBind</span> <span class="st">&quot;x&quot;</span>, <span class="dt">PBind</span> <span class="st">&quot;xs&quot;</span>], <span class="dt">PMatch</span> <span class="st">&quot;Nil&quot;</span> []]</a>
<a class="sourceLine" id="cb30-28" data-line-number="28">      runCoverageM <span class="dv">0</span> rd (checkCoverage (<span class="dt">PBind</span> <span class="dv">0</span>) branches) <span class="ot">`shouldBe`</span> (<span class="dt">Right</span> (), <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb30-29" data-line-number="29"></a>
<a class="sourceLine" id="cb30-30" data-line-number="30">    specify <span class="st">&quot;deep matching on head works&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-31" data-line-number="31">      <span class="kw">let</span> branches <span class="fu">=</span> [<span class="dt">PMatch</span> <span class="st">&quot;Cons&quot;</span> [<span class="dt">PMatch</span> <span class="st">&quot;MkUnit&quot;</span> [], <span class="dt">PBind</span> <span class="st">&quot;xs&quot;</span>], <span class="dt">PMatch</span> <span class="st">&quot;Nil&quot;</span> []]</a>
<a class="sourceLine" id="cb30-32" data-line-number="32">      runCoverageM <span class="dv">0</span> rd (checkCoverage (<span class="dt">PBind</span> <span class="dv">0</span>) branches) <span class="ot">`shouldBe`</span> (<span class="dt">Right</span> (), <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb30-33" data-line-number="33"></a>
<a class="sourceLine" id="cb30-34" data-line-number="34">    specify <span class="st">&quot;deep matching on head works&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-35" data-line-number="35">      <span class="kw">let</span> branches <span class="fu">=</span> [<span class="dt">PMatch</span> <span class="st">&quot;Cons&quot;</span> [<span class="dt">PMatch</span> <span class="st">&quot;MkUnit&quot;</span> [], <span class="dt">PBind</span> <span class="st">&quot;xs&quot;</span>], <span class="dt">PMatch</span> <span class="st">&quot;Nil&quot;</span> []]</a>
<a class="sourceLine" id="cb30-36" data-line-number="36">      runCoverageM <span class="dv">0</span> rd (checkCoverage (<span class="dt">PBind</span> <span class="dv">0</span>) branches) <span class="ot">`shouldBe`</span> (<span class="dt">Right</span> (), <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb30-37" data-line-number="37"></a>
<a class="sourceLine" id="cb30-38" data-line-number="38">  putStrLn <span class="st">&quot;All tests succeeded&quot;</span></a>
<a class="sourceLine" id="cb30-39" data-line-number="39">  pure ()</a>
<a class="sourceLine" id="cb30-40" data-line-number="40">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-41" data-line-number="41"><span class="ot">    specify ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb30-42" data-line-number="42">    specify <span class="fu">=</span> flip const</a>
<a class="sourceLine" id="cb30-43" data-line-number="43">    (<span class="fu">!</span>x) <span class="ot">`shouldBe`</span> (<span class="fu">!</span>y)</a>
<a class="sourceLine" id="cb30-44" data-line-number="44">      <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> pure ()</a>
<a class="sourceLine" id="cb30-45" data-line-number="45">      <span class="fu">|</span> otherwise <span class="fu">=</span> error <span class="fu">$</span> <span class="st">&quot;Expected &quot;</span> <span class="fu">++</span> show x <span class="fu">++</span> <span class="st">&quot; to equal &quot;</span> <span class="fu">++</span> show y</a>
<a class="sourceLine" id="cb30-46" data-line-number="46">    (<span class="fu">|-&gt;</span>) x y <span class="fu">=</span> (x,y)</a></code></pre></div>
<p>These tests are hardly exhaustive, but they will do for our purposes. Since this algorithm is quite simple yet has real-world uses, it'd be a fun exercise to write some property-based tests for it, or even to prove some simple properties about it. Off the top of my head, I can think of</p>
<ul>
<li>If <code>q</code> is successfully covered by <code>ρ</code>, then duplicating any pattern <code>ρᵢ</code> in <code>ρ</code> will cause a redundant-pattern error with <code>ρᵢ</code>.</li>
<li>If <code>q</code> is not covered by <code>ρ</code>, we can fix it by inserting a catch-all pattern into the end of <code>ρ</code>.</li>
<li>If <code>q</code> is covered by <code>ρ</code>, then <code>q `coveredBy` (PBind &quot;x&quot; : ρ)</code> will cause a redundant-pattern error with <code>ρ</code>.</li>
</ul>
<p>Furthermore, a space/time complexity analysis of the algorithm should also be an interesting (yet surmountable) task. Haskell's lazy semantics are quite useful, but always provide for extra challenge when attempting to reason about the runtime characteristics of your code.</p>
<p>That's it for now, thanks for reading!</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
